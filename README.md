# Spider Gait Generation Project/Coursework

This project uses genetic algorithms and neural networks to generate walking gaits for an 8-legged spider robot. It compares two neural network implementations: a custom implementation from scratch and PyTorch.

## Requirements

```bash
# Core dependencies
numpy
matplotlib
torch
```

## Installation

1. Clone the repository:
```bash
git clone https://github.com/AICourseworkGroup/Spider.git
cd Spider
```

2. Choose your installation method:

   **Option A - Using Conda (recommended):**
   ```bash
   conda env create -f environment.yml
   conda activate spider
   ```
   *Note: Edit `environment.yml` to uncomment GPU-specific PyTorch versions if you have NVIDIA GPU.*

   **Option B - Using pip with venv:**
   ```bash
   python3 -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   pip install -r requirements.txt
   ```
   *Note: Edit `requirements.txt` to uncomment GPU-specific PyTorch versions if you have NVIDIA/AMD/Intel GPU.*

## Project Structure

## Main.py
Main program that runs both the genetic algorithm and neural networks (self and PyTorch), It will first have the inputs for both chromosomes as variables. The parameters for the chromosomes are the two poses of the spider (standing and mid-gait pose). It will convert these parameters into radians from the math library. 

### createTargetChromosomeList
Upon setting the poses, we will progress to running the createTargetChromosomeList function, which takes in the two poses as parameters and returns a variable called GATargetPoses. This variable also displays/plots the two poses, A and B.

### display_generating_input_data(GATargetPoses)
Progressing further into the main program, we run a helper function called display_generating_input_data(GATargetPoses). This function prints out step 2, which animates the target chromosomes. after displaying text it will ask the user if they want to animate the target chromosomes or not, if the user inputs 'y' it will animate the target chromosomes. and if they press n it will skip the animation. and progress to step 3. If animation is chosen, the animation will iterate from pose A to pose B and back to pose A for 3 cycles. The function also returns maxGenerations, populationSize and mutationRate variables that are used in the genetic algorithm, as the user is required to input data for these variables.

### run_genetic_algorithm(maxGenerations, populationSize, mutationRate, GATargetPoses)
When the user inputs the required data, the main program will progress to running the genetic algorithm function called run_genetic_algorithm(GATargetPoses, maxGenerations, populationSize, mutationRate). This function takes in the target poses and the user-inputted parameters and runs the genetic algorithm to generate a walking gait for the spider robot. It returns a variable called bestChromosome, which is the best solution found by the genetic algorithm.

### display_animating_ga_generated_poses(GAPose)
display_animating_ga_generated_poses(GAPose) is the next helper function that is run in the main and prints out step 4, runs animateTargetChromosomes (GAPose, delay) and returns the animateTargetChromosomes function.

### generate_random_pose
generate_random_pose counts the number of poses generated by the genetic algorithm; from here, it will print out text that specifies how many random input poses have been generated for the neural network training. It will then create a variable called inputData that is returned from genRandomPoses with the population size set to the number of poses generated by the genetic algorithm.


### train_custom_nn(inputData, GAPoses)
This section will progress to training the custom neural network. to start off the section step 5 within the helper function of train_custom_nn(inputData, GAPoses). 

In this function, it fistly prints out the text for step 5 and then creates a variable nn that stores the full neural network as Full_NN(x (input layer size), h (hidden layer size), y (output layer size)). the input layer size is set to 24, hidden layer size is set to [512, 256] and output layer size is set to 24.

Within the same helper function, it declares nn.train_nn(x = inputData, target = GAPoses, epochs = 1000, lr = 0.01). This is where the neural network is trained with the input data and target data from the genetic algorithm poses as the target data. the epochs is how many times the neural netwrok will iterate over the traing data. lr is the learning rate it determins how much to change the model in response to the estimated error each time the model weights are updated.

### display_custom_nn_input
display_custom_nn_input prints out step 6 and creates a variable called test pose with the genRanPose funtion with a population size of 1. it generates a random test pose, displays it visually, and then returns the pose.

### display_custom_nn_output
display_custom_nn_output(testPose, nn, GATargetPoses) is the next helper function that is run in the main program. it prints out step 7 and runs a test pose through the custom neural network (nn) to get a predicted output pose,this displays the predicted pose visually, and then return the result.

### display_training_pytorch_nn
display_training_pytorch_nn(inputData, GAPoses) is step 8 in the main program imported from the helpers file. iy prints and runs the run_pytorch_nn function that trains a PYTorch neural network and returns the trained model as an output.

### display_pytorch_nn_input()
display_pytorch_nn_input() is step 9 in the main program imported from the helpers file. This function displays the PyTorch neural network input, and the testPose2 variable is created from genRanPoses with a population size of 1. This will generate a random test pose. and opens a visual display of the test pose as well as returning testpose2.

### display_pytorch_nn_output
display_pytorch_nn_output(testPose2, pytorch_model, GATargetPoses) is the final step 10 in the main program imported from the helpers file. This function takes in the test pose, the trained PyTorch model, and the target poses from the genetic algorithm. it runs the test pose through the pytorch neural network to get a predicted output pose, displays the predicted pose visually, and then returns the result.

### display_all_steps_complete
The final helper function is called display_all_steps_complete, which prints out all steps complete into the main.

## genetic_algorithm.py
For the genetic algorithm, we used Python instead of MATLAB due to not having a full understanding of the language. With the limited time constraints, we moved to python due to its simplicity through clear syntax.

### Chromosome Encoding
The "chromosome" defines a single pose for the spider. Which is is encoded as a list of 24 floating-point numbers, with each number representing a specific joint's angle in radians. The 24 joints are structured as follows:

   - 8 legs: 4 left (L1, L2, L3, L4) and 4 right (R1, R2, R3, R4).
   - 3 joints per leg: Each leg's position is determined by the angles of its
     three joints.

  The genetic algorithm evolves a population of these chromosomes to generate a walking gait, using target poses that define the key frames of the walking motion.

The structure of the inputs on each joint on targetChromosomeA  is A = math.radians(0), B= math.radians(-45) and C = math.radians(-30) and isA  = True.  

While targetchromosomeB is slightly different with targetChromosomeB is A = math.radians(20) and B = math.radians(-45) and C = math.radians(-30). 

## nn_self.py
The neural network function is a custom implemention. which when complete lears to map random spider poses to genetic algorithim generated poses, achieved through backprobagation, gradient descent and weights.

A structure of 24, 512, Sigmoid, 256, Sigmoid, 24. This is in comparison to the pytorch neural network that used ReLU instead of Sigmoid, changed due to undesirable leg positions. We believe this to be the case due to pytorch having a different learning rate from the Adam optimiser.  

## nn_pytorch.py
The PyTorch neural network implementation uses the PyTorch library to create and train a neural network that maps random spider poses to genetic algorithm-generated poses. The network architecture consists of an input layer with 24 neurons, two hidden layers with 512 and 256 neurons respectively, and an output layer with 24 neurons. The ReLU activation function is used for the hidden layers, and the Adam optimiser is applied for training.

## forward_leg_kinematics.py
This file contains the forward leg kinematics calculations for the spider for a single spider leg., and is used for 3 degrees of movement freedom. the 3 legs are Coax (upper most joint that rotates in x-axis) , Femur (middle joint that rotates in y-axis) and Tibia (lower joint that rotates in y-axis).

It uses these input angles and handles the rotation matricies to calculate the 3D position of the spider leg's end effector (the tip of the leg). This is crucial for visualising the spider's pose and ensuring that the generated poses are physically feasible.

## spider_pose.py
This file handles the 3D visualization of the spider poses. It uses Matplotlib to create 3D plots of the spider based on the joint angles provided in the chromosome. The visualisation includes all 8 legs of the spider, each represented by lines connecting the joints calculated using forward kinematics.

## helpers.py
The helpers.py file contains various functions that assist with isolating different parts of the main program for better organisation and readability. These functions handle tasks such as displaying target chromosomes, animating poses, training neural networks, and displaying results.

# Genetic Algorithm Detailed Explanations
## Fitness Function
1. we call calculateFitness() which will take the difference between the two chromosomes. By doing this, we can see how much a generated chromosome overlaps with the target. The closer it is to 0, the more it matches.  

2. For the index of the best fitness for later. The variable that stores the current best fitness is initialised with infinity. This way, no matter what the fitness of the first chromosome is, it’ll be less than the variable and get assigned.  

3. We also store the index of the 2nd-best fitness. By doing this, we can choose the best 2 parents from each generation to use for crossover later when making a new population. 

We're using tournament selection to get the 2 best parents in a large population. This is done by randomly selecting chromosomes from the population and comparing their fitness values. The chromosome with the highest ftness is selected and the process is repeated to find the second best parent. We chose this method over roulette wheel selection as the roulette wheel has a higher bias towards higher fitness scores, but doesn't always select the best chromosomes for the parents.

## Create Population
1. The first step of our genetic algorithm is to generate our initial population. We do this in the createRandomPopulation() function. This function takes a population size given by the user as a parameter.

The population uses the length of the for loopwhere the population is made. we then initialise the population by setting variables for each leg with randomly generated radians that are generated in a separate function randRadianGen(). 

2. We then append this chromosome to the population list with all of the angles added to each other in the list.  

## Create New Population
1. We run createNewPopulation() function which takes the two best parents and the population size as paramaters. It then runs a for loop that runs for the total population / 2.  

2. We then create two new list variables that have half of the new population stored in each of them.  

## Crossover
It works by taking the two best parents from a given generation as parameters. We then randomly generate a crossover point. On either side of this point is where the values of the new child swap from the values of chromosome A to chromosome B to ensure genetic diversity. 

Crossover returns these newly created chromosomes which are then appended to a newPopulation list variable back in the original function.

## Mutation
1. We perform mutation on the new chromosome to give further diversity. This function takes the chromosome and a mutation rate determined by the user as parameters. 

2. It then goes through every angle in the chromosome and generates a random number between 0 and 1. If this number is smaller than the mutation rate then that angle is mutated by giving it a new randomly generated one. 



```
Spider/
├── main.py 
├── genetic_algorithm.py             # GA implementation for pose generation
├── nn_self.py                       # Custom neural network from scratch - based on AI Practical 5
├── nn_pytorch.py                    # PyTorch neural network implementation
├── forward_leg_kinematics.py        # 3D forward kinematics for spider legs
├── spider_pose.py                   # 3D visualization of spider poses
├── helpers.py                       # Helper functions for display and user interaction
└── README.md                        # This file
```



## Usage

### Run the Full Pipeline

```bash
python main.py
```

This will execute the following steps:

1. **Display Target Chromosomes**: Shows the two key poses (standing and mid-walk).
2. **Run Genetic Algorithm**: Prompts the user for parameters (generations, population size, mutation rate), then evolves poses to match targets.
3. **Animate GA Poses**: Displays the GA-generated walk cycle.
4. **Train Custom Neural Network**: Trains the from-scratch implementation (`nn_self.py`).
5. **Display Custom NN Output**: Shows the network's prediction compared to the target.
6. **Train PyTorch Neural Network**: Trains the PyTorch implementation (`nn_pytorch.py`).
7. **Display PyTorch NN Output**: Shows the network's prediction compared to the target.

## Credits

- **Forward kinematics (`forward_leg_kinematics.py`) and plotting functions (`spider_pose.py`)**: Originally provided in MATLAB, translated to Python using Gemini 2.5 Pro.
- **Custom neural network (`nn_self.py`)**: Based on code from AI Practical 5.
- **GitHub Copilot**: Used for syntax help and code autocomplete throughout development.

## Repository

https://github.com/AICourseworkGroup/Spider

## Assignment Related Documentation

https://portdotacdotuk-my.sharepoint.com/:w:/g/personal/up2114856_myport_ac_uk/IQAAS21bX1x4QodRN3o5yKCYAUuzCUWxn4VL7oowhPOyW0M?e=4nroir
